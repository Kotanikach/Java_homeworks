/**
 * Практика #1 Объясните, почему в цикле for (1) будут другие результаты, чем в следующих затем вызовах (2), хотя аргументы одинаковые?
 */
 public class A {
    public void printNum(Integer i)
    {
        System.out.printf("Integer = %d%n", i);
    }
    public void printNum(int i)
    {
        System.out.printf("int = %d%n", i);
    }
    public void printNum(Float f)
    {
        System.out.printf("Float = %.4f%n", f);
    }
    public void printNum(Number n)
    {
        System.out.println("Number=" + n);
    }
}


public class Main {
    public static void main(String[] args) {
        A a = new A();
        Number[ ] num = {new Integer(1), 11, 1.11f, 11.11 };
        // цикл for (1)
        for (Number n : num) {
            a.printNum(n);
        }
        // (2)
        a.printNum(new Integer(1));
        a.printNum(11);
        a.printNum(1.11f);
        a.printNum(11.11);
    }
}

Цикл for (1): В цикле переменная n имеет тип Number. Это означает, что вызов a.printNum(n) будет всегда рассматриваться как вызов метода printNum(Number n), поскольку для компилятора это наиболее подходящий вариант из перегруженных методов. Следовательно, для всех элементов массива num будет вызываться именно метод, который принимает аргумент типа Number:
Number = 1
Number = 11
Number = 1.11
Number = 11.11

Причина, по которой во всех случаях вызывается метод с параметром типа Number, заключается в том, что тип переменной цикла — Number, и компилятор выбирает метод на основе типа аргумента во время компиляции. В данном случае метод printNum(Number) является самым подходящим для каждого элемента массива.

Прямые вызовы (2) после цикла: После цикла, при прямом вызове методов с конкретными типами аргументов, компилятор выбирает наиболее специфичную перегруженную версию метода в зависимости от типа переданного аргумента.

Вызов a.printNum(new Integer(1)); — будет вызван метод printNum(Integer i):
Integer = 1

Вызов a.printNum(11); — будет вызван метод printNum(int i):
int = 11

Вызов a.printNum(1.11f); — будет вызван метод printNum(Float f):
Float = 1.1100

Вызов a.printNum(11.11); — компилятор преобразует значение 11.11 (тип double) в Number, и вызовется метод printNum(Number n):
Number = 11.11

Различия между вызовами в цикле (1) и после него (2):
В цикле for (1) каждый элемент массива имеет тип Number, что заставляет компилятор выбрать метод с параметром типа Number, независимо от фактического типа каждого элемента (например, Integer, Float и т.д.).
В вызовах (2) аргументы передаются явно с конкретными типами (Integer, int, Float, double), что позволяет компилятору выбрать наиболее подходящую перегруженную версию метода, соответствующую типу переданного аргумента.

Окончательный вывод:
Цикл for (1):
Number = 1
Number = 11
Number = 1.11
Number = 11.11

Вызовы (2) после цикла:
Integer = 1
int = 11
Float = 1.1100
Number = 11.11

Эти результаты демонстрируют, как перегрузка методов выбирается на основе типов аргументов на этапе компиляции.
